import {
  require_authRecipe,
  require_build,
  require_genericComponentOverrideContext,
  require_multifactorauth_shared,
  require_normalisedURLPath,
  require_postSuperTokensInitCallbacks,
  require_postSuperTokensInitCallbacks2,
  require_querier,
  require_recipeModule_shared,
  require_sessionClaimValidatorStore,
  require_utils,
  require_utils2,
  require_utils3,
  require_windowHandler
} from "./chunk-I3ITGVEN.js";
import {
  require_jsx_runtime
} from "./chunk-BX4QH3UP.js";
import {
  require_react_dom
} from "./chunk-GZ55BCQ2.js";
import {
  require_react
} from "./chunk-YZZKIYU7.js";
import {
  __commonJS
} from "./chunk-LQ2VYIYD.js";

// node_modules/supertokens-auth-react/lib/build/translationContext.js
var require_translationContext = __commonJS({
  "node_modules/supertokens-auth-react/lib/build/translationContext.js"(exports) {
    "use strict";
    var genericComponentOverrideContext = require_genericComponentOverrideContext();
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var React__default = _interopDefault(React);
    var errCB = function() {
      throw new Error("Cannot use translation func outside TranslationContext provider.");
    };
    var TranslationContext = React__default.default.createContext({
      translate: errCB
    });
    var useTranslation = function() {
      return React.useContext(TranslationContext).translate;
    };
    var TranslationContextProvider = function(_a) {
      var children = _a.children, defaultLanguage = _a.defaultLanguage, userTranslationFunc = _a.userTranslationFunc, defaultStore = _a.defaultStore, translationControlEventSource = _a.translationControlEventSource;
      var _b = React.useState(defaultStore), translationStore = _b[0], setTranslationStore = _b[1];
      var _c = React.useState(void 0), currentLanguage = _c[0], setCurrentLanguage = _c[1];
      React.useEffect(
        function() {
          function loadLanguageFromCookies() {
            return genericComponentOverrideContext.__awaiter(this, void 0, void 0, function() {
              var cookieLang, cookieLangTemp;
              return genericComponentOverrideContext.__generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    return [4, genericComponentOverrideContext.getCurrentLanguageFromCookie()];
                  case 1:
                    cookieLang = _a2.sent();
                    cookieLangTemp = cookieLang === null ? defaultLanguage : cookieLang;
                    setCurrentLanguage(function(current) {
                      return current !== void 0 ? current : cookieLangTemp;
                    });
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }
          void loadLanguageFromCookies();
        },
        [defaultLanguage, setCurrentLanguage]
      );
      React.useEffect(function() {
        var changeHandler = function(_eventName, detail) {
          setCurrentLanguage(detail);
        };
        var loadHandler = function(_eventName, detail) {
          setTranslationStore(function(os) {
            return genericComponentOverrideContext.mergeObjects(os, detail);
          });
        };
        translationControlEventSource.on("LanguageChange", changeHandler);
        translationControlEventSource.on("TranslationLoaded", loadHandler);
        return function() {
          translationControlEventSource.off("LanguageChange", changeHandler);
          translationControlEventSource.off("TranslationLoaded", loadHandler);
        };
      });
      var translateFunc = React.useCallback(
        function(key) {
          if (userTranslationFunc !== void 0) {
            return userTranslationFunc(key);
          }
          if (currentLanguage !== void 0) {
            var res = translationStore[currentLanguage] && translationStore[currentLanguage][key];
            var fallback = translationStore[defaultLanguage] && translationStore[defaultLanguage][key];
            if (res === void 0) {
              if (fallback !== void 0) {
                return fallback;
              }
              return key;
            }
            return res;
          }
          throw new Error("Should never come here");
        },
        [translationStore, currentLanguage, defaultLanguage, userTranslationFunc]
      );
      if (currentLanguage === void 0) {
        return null;
      }
      return jsxRuntime.jsx(
        TranslationContext.Provider,
        genericComponentOverrideContext.__assign({ value: { translate: translateFunc } }, { children })
      );
    };
    exports.TranslationContextProvider = TranslationContextProvider;
    exports.useTranslation = useTranslation;
  }
});

// node_modules/supertokens-auth-react/lib/build/multitenancy-shared.js
var require_multitenancy_shared = __commonJS({
  "node_modules/supertokens-auth-react/lib/build/multitenancy-shared.js"(exports) {
    "use strict";
    var genericComponentOverrideContext = require_genericComponentOverrideContext();
    var _a = genericComponentOverrideContext.createGenericComponentsOverrideContext();
    var useContext = _a[0];
    var Provider = _a[1];
    exports.Provider = Provider;
    exports.useContext = useContext;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/utils.js
var require_utils4 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/utils.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkFactorRequirement = exports.normaliseUserInput = void 0;
    var utils_1 = require_utils2();
    function normaliseUserInput(config) {
      var override = __assign(
        {
          functions: function(originalImplementation) {
            return originalImplementation;
          }
        },
        config.override
      );
      return __assign(__assign({}, (0, utils_1.normaliseAuthRecipe)(config)), { override });
    }
    exports.normaliseUserInput = normaliseUserInput;
    function checkFactorRequirement(req, completedFactors) {
      return {
        id: req,
        isValid: completedFactors[req] !== void 0,
        message: "Not completed"
      };
    }
    exports.checkFactorRequirement = checkFactorRequirement;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/multiFactorAuthClaim.js
var require_multiFactorAuthClaim = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/multiFactorAuthClaim.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiFactorAuthClaimClass = void 0;
    var utils_1 = require_utils4();
    var MultiFactorAuthClaimClass = (
      /** @class */
      function() {
        function MultiFactorAuthClaimClass2(getRecipeImpl) {
          var _this = this;
          this.getRecipeImpl = getRecipeImpl;
          this.id = "st-mfa";
          this.validators = {
            hasCompletedMFARequirementsForAuth: function() {
              return {
                id: _this.id,
                refresh: function() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                  }
                  return _this.refresh.apply(_this, args);
                },
                shouldRefresh: function(payload, userContext) {
                  var val = _this.getValueFromPayload(payload, userContext);
                  return val === void 0;
                },
                validate: function(payload, userContext) {
                  return __awaiter(_this, void 0, void 0, function() {
                    var val;
                    return __generator(this, function(_a) {
                      val = this.getValueFromPayload(payload, userContext);
                      if (val === void 0) {
                        return [
                          2,
                          {
                            isValid: false,
                            reason: {
                              message: "MFA info not available in payload"
                            }
                          }
                        ];
                      }
                      if (val.v) {
                        return [
                          2,
                          {
                            isValid: true
                          }
                        ];
                      }
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "not all required factors have been completed"
                          }
                        }
                      ];
                    });
                  });
                }
              };
            },
            hasCompletedFactors: function(requirements) {
              return {
                id: _this.id,
                shouldRefresh: function(payload, userContext) {
                  var val = _this.getValueFromPayload(payload, userContext);
                  return val === void 0;
                },
                refresh: function() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                  }
                  return _this.refresh.apply(_this, args);
                },
                validate: function(payload, userContext) {
                  var val = _this.getValueFromPayload(payload, userContext);
                  if (val === void 0) {
                    return {
                      isValid: false,
                      reason: {
                        message: "MFA info not available in payload"
                      }
                    };
                  }
                  var completedFactors = val.c;
                  for (var _i = 0, requirements_1 = requirements; _i < requirements_1.length; _i++) {
                    var req = requirements_1[_i];
                    if (typeof req === "object" && "oneOf" in req) {
                      var res = req.oneOf.map(function(r) {
                        return (0, utils_1.checkFactorRequirement)(r, completedFactors);
                      }).filter(function(v) {
                        return v.isValid === false;
                      });
                      if (res.length === req.oneOf.length) {
                        return {
                          isValid: false,
                          reason: {
                            message: "All factor checkers failed in the list",
                            oneOf: req.oneOf,
                            failures: res
                          }
                        };
                      }
                    } else if (typeof req === "object" && "allOfInAnyOrder" in req) {
                      var res = req.allOfInAnyOrder.map(function(r) {
                        return (0, utils_1.checkFactorRequirement)(r, completedFactors);
                      }).filter(function(v) {
                        return v.isValid === false;
                      });
                      if (res.length !== 0) {
                        return {
                          isValid: false,
                          reason: {
                            message: "Some factor checkers failed in the list",
                            allOfInAnyOrder: req.allOfInAnyOrder,
                            failures: res
                          }
                        };
                      }
                    } else {
                      var res = (0, utils_1.checkFactorRequirement)(req, completedFactors);
                      if (res.isValid !== true) {
                        return {
                          isValid: false,
                          reason: {
                            message: "Factor validation failed: " + res.message,
                            factorId: res.id
                          }
                        };
                      }
                    }
                  }
                  return {
                    isValid: true
                  };
                }
              };
            }
          };
        }
        MultiFactorAuthClaimClass2.prototype.refresh = function(userContext) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getRecipeImpl().resyncSessionAndFetchMFAInfo(userContext)];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        MultiFactorAuthClaimClass2.prototype.getValueFromPayload = function(payload, _userContext) {
          if (payload[this.id] === void 0) {
            return void 0;
          }
          return {
            c: payload[this.id].c,
            v: payload[this.id].v
          };
        };
        MultiFactorAuthClaimClass2.prototype.getLastFetchedTime = function(payload, _userContext) {
          var _a;
          return (_a = payload[this.id]) === null || _a === void 0 ? void 0 : _a.t;
        };
        return MultiFactorAuthClaimClass2;
      }()
    );
    exports.MultiFactorAuthClaimClass = MultiFactorAuthClaimClass;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/recipeImplementation.js
var require_recipeImplementation = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/recipeImplementation.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRecipeImplementation = void 0;
    var querier_1 = require_querier();
    function getRecipeImplementation(recipeImplInput) {
      var querier = new querier_1.default(recipeImplInput.recipeId, recipeImplInput.appInfo);
      return {
        resyncSessionAndFetchMFAInfo: function(_a) {
          var options = _a.options, userContext = _a.userContext;
          return __awaiter(this, void 0, void 0, function() {
            var _b, jsonBody, fetchResponse;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [
                    4,
                    querier.put(
                      void 0,
                      "/mfa/info",
                      {},
                      querier_1.default.preparePreAPIHook({
                        recipePreAPIHook: recipeImplInput.preAPIHook,
                        action: "GET_MFA_INFO",
                        options,
                        userContext
                      }),
                      querier_1.default.preparePostAPIHook({
                        recipePostAPIHook: recipeImplInput.postAPIHook,
                        action: "GET_MFA_INFO",
                        userContext
                      })
                    )
                  ];
                case 1:
                  _b = _c.sent(), jsonBody = _b.jsonBody, fetchResponse = _b.fetchResponse;
                  return [2, __assign(__assign({}, jsonBody), { fetchResponse })];
              }
            });
          });
        }
      };
    }
    exports.default = getRecipeImplementation;
    exports.getRecipeImplementation = getRecipeImplementation;
  }
});

// node_modules/supertokens-website/utils/sessionClaimValidatorStore/index.js
var require_sessionClaimValidatorStore2 = __commonJS({
  "node_modules/supertokens-website/utils/sessionClaimValidatorStore/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    var d = require_sessionClaimValidatorStore();
    if (d.default !== void 0) {
      __export(d);
    } else {
      __export({
        default: d,
        ...d
      });
    }
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/recipe.js
var require_recipe = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/recipe.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Recipe = void 0;
    var utils_1 = require_utils4();
    var supertokens_js_override_1 = require_build();
    var recipeImplementation_1 = require_recipeImplementation();
    var utils_2 = require_utils();
    var authRecipe_1 = require_authRecipe();
    var postSuperTokensInitCallbacks_1 = require_postSuperTokensInitCallbacks();
    var sessionClaimValidatorStore_1 = require_sessionClaimValidatorStore2();
    var multiFactorAuthClaim_1 = require_multiFactorAuthClaim();
    var Recipe = (
      /** @class */
      function(_super) {
        __extends(Recipe2, _super);
        function Recipe2(config) {
          var _this = _super.call(this, (0, utils_1.normaliseUserInput)(config)) || this;
          var builder = new supertokens_js_override_1.default(
            (0, recipeImplementation_1.default)({
              recipeId: _this.config.recipeId,
              appInfo: _this.config.appInfo,
              clientType: _this.config.clientType,
              preAPIHook: _this.config.preAPIHook,
              postAPIHook: _this.config.postAPIHook
            })
          );
          _this.recipeImplementation = builder.override(_this.config.override.functions).build();
          postSuperTokensInitCallbacks_1.PostSuperTokensInitCallbacks.addPostInitCallback(function() {
            sessionClaimValidatorStore_1.SessionClaimValidatorStore.addClaimValidatorFromOtherRecipe(
              Recipe2.MultiFactorAuthClaim.validators.hasCompletedMFARequirementsForAuth()
            );
          });
          return _this;
        }
        Recipe2.init = function(config) {
          return function(appInfo, clientType) {
            Recipe2.instance = new Recipe2(
              __assign(__assign({}, config), { recipeId: Recipe2.RECIPE_ID, appInfo, clientType })
            );
            return Recipe2.instance;
          };
        };
        Recipe2.getInstanceOrThrow = function() {
          if (Recipe2.instance === void 0) {
            var error = "No instance of MultiFactorAuth found. Make sure to call the MultiFactorAuth.init method.";
            error = (0, utils_2.checkForSSRErrorAndAppendIfNeeded)(error);
            throw Error(error);
          }
          return Recipe2.instance;
        };
        Recipe2.reset = function() {
          if (!(0, utils_2.isTest)()) {
            return;
          }
          Recipe2.instance = void 0;
          return;
        };
        Recipe2.RECIPE_ID = "multifactorauth";
        Recipe2.MultiFactorAuthClaim = new multiFactorAuthClaim_1.MultiFactorAuthClaimClass(function() {
          return Recipe2.getInstanceOrThrow().recipeImplementation;
        });
        return Recipe2;
      }(authRecipe_1.default)
    );
    exports.Recipe = Recipe;
    exports.default = Recipe;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/index.js
var require_multifactorauth = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multifactorauth/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiFactorAuthClaimClass = exports.MultiFactorAuthClaim = exports.resyncSessionAndFetchMFAInfo = exports.init = void 0;
    var multiFactorAuthClaim_1 = require_multiFactorAuthClaim();
    Object.defineProperty(exports, "MultiFactorAuthClaimClass", {
      enumerable: true,
      get: function() {
        return multiFactorAuthClaim_1.MultiFactorAuthClaimClass;
      }
    });
    var recipe_1 = require_recipe();
    var utils_1 = require_utils();
    var RecipeWrapper = (
      /** @class */
      function() {
        function RecipeWrapper2() {
        }
        RecipeWrapper2.init = function(config) {
          return recipe_1.default.init(config);
        };
        RecipeWrapper2.resyncSessionAndFetchMFAInfo = function(input) {
          var _a;
          return recipe_1.default.getInstanceOrThrow().recipeImplementation.resyncSessionAndFetchMFAInfo({
            options: (_a = input === null || input === void 0 ? void 0 : input.options) !== null && _a !== void 0 ? _a : {},
            userContext: (0, utils_1.getNormalisedUserContext)(
              input === null || input === void 0 ? void 0 : input.userContext
            )
          });
        };
        RecipeWrapper2.MultiFactorAuthClaim = recipe_1.default.MultiFactorAuthClaim;
        return RecipeWrapper2;
      }()
    );
    exports.default = RecipeWrapper;
    var init = RecipeWrapper.init;
    exports.init = init;
    var resyncSessionAndFetchMFAInfo = RecipeWrapper.resyncSessionAndFetchMFAInfo;
    exports.resyncSessionAndFetchMFAInfo = resyncSessionAndFetchMFAInfo;
    var MultiFactorAuthClaim = RecipeWrapper.MultiFactorAuthClaim;
    exports.MultiFactorAuthClaim = MultiFactorAuthClaim;
  }
});

// node_modules/supertokens-web-js/recipe/multifactorauth/index.js
var require_multifactorauth2 = __commonJS({
  "node_modules/supertokens-web-js/recipe/multifactorauth/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_multifactorauth());
  }
});

// node_modules/supertokens-web-js/lib/build/sessionClaimValidatorStore.js
var require_sessionClaimValidatorStore3 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/sessionClaimValidatorStore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SessionClaimValidatorStore = void 0;
    var sessionClaimValidatorStore_1 = require_sessionClaimValidatorStore2();
    Object.defineProperty(exports, "SessionClaimValidatorStore", {
      enumerable: true,
      get: function() {
        return sessionClaimValidatorStore_1.SessionClaimValidatorStore;
      }
    });
  }
});

// node_modules/supertokens-web-js/utils/sessionClaimValidatorStore.js
var require_sessionClaimValidatorStore4 = __commonJS({
  "node_modules/supertokens-web-js/utils/sessionClaimValidatorStore.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    var d = require_sessionClaimValidatorStore3();
    if (d.default !== void 0) {
      __export(d);
    } else {
      __export({
        default: d,
        ...d
      });
    }
  }
});

// node_modules/supertokens-auth-react/lib/build/multifactorauth-shared2.js
var require_multifactorauth_shared2 = __commonJS({
  "node_modules/supertokens-auth-react/lib/build/multifactorauth-shared2.js"(exports) {
    "use strict";
    var genericComponentOverrideContext = require_genericComponentOverrideContext();
    var MultiFactorAuthWebJS = require_multifactorauth2();
    var utils = require_utils3();
    var NormalisedURLPath = require_normalisedURLPath();
    var postSuperTokensInitCallbacks = require_postSuperTokensInitCallbacks2();
    var sessionClaimValidatorStore = require_sessionClaimValidatorStore4();
    var windowHandler = require_windowHandler();
    var index = require_recipeModule_shared();
    var types = require_multifactorauth_shared();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var MultiFactorAuthWebJS__default = _interopDefault(MultiFactorAuthWebJS);
    var NormalisedURLPath__default = _interopDefault(NormalisedURLPath);
    var DEFAULT_FACTOR_CHOOSER_PATH = "/mfa";
    var MFA_INFO_CACHE_KEY = "st-mfa-info-cache";
    var lockProm = void 0;
    var getFunctionOverrides = function(_onHandleEvent) {
      return function(originalImp) {
        return genericComponentOverrideContext.__assign(genericComponentOverrideContext.__assign({}, originalImp), {
          resyncSessionAndFetchMFAInfo: function(input) {
            return genericComponentOverrideContext.__awaiter(this, void 0, void 0, function() {
              var stWindow, stored, parsed, unlock, stored_1, parsed, val;
              return genericComponentOverrideContext.__generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    stWindow = windowHandler.WindowHandlerReference.getReferenceOrThrow();
                    return [4, lockProm];
                  case 1:
                    _a.sent();
                    return [4, stWindow.windowHandler.sessionStorage.getItem(MFA_INFO_CACHE_KEY)];
                  case 2:
                    stored = _a.sent();
                    if (stored !== null) {
                      parsed = JSON.parse(stored);
                      if (parsed.t > Date.now() - 1e3) {
                        return [
                          2,
                          genericComponentOverrideContext.__assign(
                            genericComponentOverrideContext.__assign({}, parsed.v),
                            {
                              // Adding a fake response is not great, but we do want to add something and this way it's detectable by the app
                              // so they could even add specific handling for it if they preferred.
                              fetchResponse: new Response(null, { status: 304 })
                            }
                          )
                        ];
                      }
                    }
                    _a.label = 3;
                  case 3:
                    if (!(lockProm !== void 0))
                      return [3, 5];
                    return [4, lockProm];
                  case 4:
                    _a.sent();
                    return [3, 3];
                  case 5:
                    lockProm = new Promise(function(res) {
                      return unlock = res;
                    });
                    _a.label = 6;
                  case 6:
                    _a.trys.push([6, , 11, 12]);
                    return [4, stWindow.windowHandler.sessionStorage.getItem(MFA_INFO_CACHE_KEY)];
                  case 7:
                    stored_1 = _a.sent();
                    if (stored_1 !== null) {
                      parsed = JSON.parse(stored_1);
                      if (parsed.t > Date.now() - 1e3) {
                        return [
                          2,
                          genericComponentOverrideContext.__assign(
                            genericComponentOverrideContext.__assign({}, parsed.v),
                            {
                              // Adding a fake response is not great, but we do want to add something and this way it's detectable by the app
                              // so they could even add specific handling for it if they preferred.
                              fetchResponse: new Response(null, { status: 304 })
                            }
                          )
                        ];
                      }
                    }
                    return [4, originalImp.resyncSessionAndFetchMFAInfo(input)];
                  case 8:
                    val = _a.sent();
                    if (!(val.status === "OK"))
                      return [3, 10];
                    return [
                      4,
                      stWindow.windowHandler.sessionStorage.setItem(
                        MFA_INFO_CACHE_KEY,
                        JSON.stringify({
                          t: Date.now(),
                          v: {
                            emails: val.emails,
                            phoneNumbers: val.phoneNumbers,
                            factors: val.factors,
                            status: val.status
                          }
                        })
                      )
                    ];
                  case 9:
                    _a.sent();
                    _a.label = 10;
                  case 10:
                    return [2, val];
                  case 11:
                    lockProm = void 0;
                    unlock();
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 12:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }
        });
      };
    };
    var MultiFactorAuthClaimClass = (
      /** @class */
      /* @__PURE__ */ function() {
        function MultiFactorAuthClaimClass2(getRecipe, getRedirectURL, onFailureRedirection) {
          var _this = this;
          this.webJSClaim = new MultiFactorAuthWebJS.MultiFactorAuthClaimClass(function() {
            return getRecipe().webJSRecipe;
          });
          this.refresh = this.webJSClaim.refresh;
          this.getLastFetchedTime = this.webJSClaim.getLastFetchedTime;
          this.getValueFromPayload = this.webJSClaim.getValueFromPayload;
          this.id = this.webJSClaim.id;
          var defaultOnFailureRedirection = function(_a) {
            var reason = _a.reason, userContext = _a.userContext;
            return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
              var recipe, nextFactorOptions, availableFactors, mfaInfo_1, availableFactors;
              return genericComponentOverrideContext.__generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    recipe = getRecipe();
                    nextFactorOptions = reason.oneOf || reason.allOfInAnyOrder || (reason.factorId !== void 0 ? [reason.factorId] : void 0);
                    if (!(nextFactorOptions !== void 0))
                      return [3, 1];
                    genericComponentOverrideContext.logDebugMessage(
                      "Redirecting to MFA on next array from validation failure: " + nextFactorOptions.join(", ")
                    );
                    availableFactors = recipe.getSecondaryFactors(userContext).filter(function(v) {
                      return nextFactorOptions.factors.next.includes(v.id);
                    }).map(function(v) {
                      return v.id;
                    });
                    if (availableFactors.length === 1) {
                      return [
                        2,
                        getRedirectURL(
                          { action: "GO_TO_FACTOR", factorId: availableFactors[0] },
                          userContext
                        )
                      ];
                    } else {
                      return [
                        2,
                        getRedirectURL(
                          { action: "FACTOR_CHOOSER", nextFactorOptions },
                          userContext
                        )
                      ];
                    }
                  case 1:
                    return [
                      4,
                      recipe.webJSRecipe.resyncSessionAndFetchMFAInfo({ userContext })
                    ];
                  case 2:
                    mfaInfo_1 = _b.sent();
                    availableFactors = recipe.getSecondaryFactors(userContext).filter(function(v) {
                      return mfaInfo_1.factors.next.includes(v.id);
                    }).map(function(v) {
                      return v.id;
                    });
                    if (availableFactors.length !== 0) {
                      genericComponentOverrideContext.logDebugMessage(
                        "Redirecting to MFA on next array from backend: " + availableFactors.join(", ")
                      );
                      if (availableFactors.length === 1) {
                        return [
                          2,
                          getRedirectURL(
                            { action: "GO_TO_FACTOR", factorId: availableFactors[0] },
                            userContext
                          )
                        ];
                      } else {
                        return [2, getRedirectURL({ action: "FACTOR_CHOOSER" }, userContext)];
                      }
                    }
                    _b.label = 3;
                  case 3:
                    return [2, void 0];
                }
              });
            });
          };
          this.validators = genericComponentOverrideContext.__assign(
            genericComponentOverrideContext.__assign({}, this.webJSClaim.validators),
            {
              hasCompletedMFARequirementsForAuth: function(doRedirection, showAccessDeniedOnFailure) {
                if (doRedirection === void 0) {
                  doRedirection = true;
                }
                if (showAccessDeniedOnFailure === void 0) {
                  showAccessDeniedOnFailure = true;
                }
                var orig = _this.webJSClaim.validators.hasCompletedMFARequirementsForAuth();
                return genericComponentOverrideContext.__assign(
                  genericComponentOverrideContext.__assign({}, orig),
                  {
                    showAccessDeniedOnFailure,
                    onFailureRedirection: onFailureRedirection !== null && onFailureRedirection !== void 0 ? onFailureRedirection : function(_a) {
                      var reason = _a.reason, userContext = _a.userContext;
                      return doRedirection ? defaultOnFailureRedirection({
                        reason,
                        userContext
                      }) : void 0;
                    }
                  }
                );
              },
              hasCompletedFactors: function(requirements, doRedirection, showAccessDeniedOnFailure) {
                if (doRedirection === void 0) {
                  doRedirection = true;
                }
                if (showAccessDeniedOnFailure === void 0) {
                  showAccessDeniedOnFailure = true;
                }
                var orig = _this.webJSClaim.validators.hasCompletedFactors(requirements);
                return genericComponentOverrideContext.__assign(
                  genericComponentOverrideContext.__assign({}, orig),
                  {
                    showAccessDeniedOnFailure,
                    onFailureRedirection: onFailureRedirection !== null && onFailureRedirection !== void 0 ? onFailureRedirection : function(_a) {
                      var reason = _a.reason, userContext = _a.userContext;
                      return doRedirection ? defaultOnFailureRedirection({
                        reason,
                        userContext
                      }) : void 0;
                    }
                  }
                );
              }
            }
          );
        }
        return MultiFactorAuthClaimClass2;
      }()
    );
    function normaliseMultiFactorAuthFeature(config) {
      var _a;
      if (config === void 0) {
        config = {};
      }
      var disableDefaultUI = config.disableDefaultUI === true;
      var override = genericComponentOverrideContext.__assign(
        {
          functions: function(originalImplementation) {
            return originalImplementation;
          }
        },
        config.override
      );
      return genericComponentOverrideContext.__assign(
        genericComponentOverrideContext.__assign(
          {},
          genericComponentOverrideContext.normaliseRecipeModuleConfig(config)
        ),
        {
          disableDefaultUI,
          firstFactors: config === null || config === void 0 ? void 0 : config.firstFactors,
          getSecondaryFactorInfo: function(orig) {
            return orig;
          },
          factorChooserScreen: (_a = config.factorChooserScreen) !== null && _a !== void 0 ? _a : {},
          override
        }
      );
    }
    function getAvailableFactors(factors, nextArrayQueryParam, recipe, userContext) {
      var nextArr = nextArrayQueryParam !== void 0 ? nextArrayQueryParam.split(",") : factors.next;
      var availableFactors = recipe.getSecondaryFactors(userContext).filter(function(_a) {
        var id = _a.id;
        return nextArr.length === 0 ? factors.allowedToSetup.includes(id) || factors.alreadySetup.includes(id) : nextArr.includes(id);
      });
      return availableFactors;
    }
    var MultiFactorAuth = (
      /** @class */
      function(_super) {
        genericComponentOverrideContext.__extends(MultiFactorAuth2, _super);
        function MultiFactorAuth2(config, webJSRecipe) {
          if (webJSRecipe === void 0) {
            webJSRecipe = MultiFactorAuthWebJS__default.default;
          }
          var _this = _super.call(this, config) || this;
          _this.webJSRecipe = webJSRecipe;
          _this.recipeID = MultiFactorAuth2.RECIPE_ID;
          _this.secondaryFactors = [];
          _this.getDefaultRedirectionURL = function(context, userContext) {
            return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
              var chooserPath, url, redirectInfo, url;
              return genericComponentOverrideContext.__generator(this, function(_b) {
                if (context.action === "FACTOR_CHOOSER") {
                  chooserPath = new NormalisedURLPath__default.default(DEFAULT_FACTOR_CHOOSER_PATH);
                  url = this.config.appInfo.websiteBasePath.appendPath(chooserPath).getAsStringDangerous();
                  if (context.nextFactorOptions && context.nextFactorOptions.length > 0) {
                    url += "?n=".concat(context.nextFactorOptions.join(","));
                  }
                  return [2, url];
                } else if (context.action === "GO_TO_FACTOR") {
                  redirectInfo = this.getSecondaryFactors(userContext).find(function(f) {
                    return f.id === context.factorId;
                  });
                  if (redirectInfo !== void 0) {
                    url = this.config.appInfo.websiteBasePath.appendPath(new NormalisedURLPath__default.default(redirectInfo.path)).getAsStringDangerous();
                    if (context.forceSetup) {
                      url += "?setup=true";
                    }
                    return [2, url];
                  }
                  throw new Error("Requested redirect to unknown factor id: " + context.factorId);
                } else {
                  return [2, "/"];
                }
              });
            });
          };
          postSuperTokensInitCallbacks.PostSuperTokensInitCallbacks.addPostInitCallback(function() {
            var defaultFactorsValidator = MultiFactorAuth2.MultiFactorAuthClaim.validators.hasCompletedMFARequirementsForAuth();
            sessionClaimValidatorStore.SessionClaimValidatorStore.addClaimValidatorFromOtherRecipe(
              defaultFactorsValidator
            );
            types.Session.getInstanceOrThrow().addEventListener(function() {
              var stWindow = windowHandler.WindowHandlerReference.getReferenceOrThrow();
              stWindow.windowHandler.sessionStorage.removeItemSync(MFA_INFO_CACHE_KEY);
            });
          });
          return _this;
        }
        MultiFactorAuth2.init = function(config) {
          var normalisedConfig = normaliseMultiFactorAuthFeature(config);
          return {
            recipeID: MultiFactorAuth2.RECIPE_ID,
            authReact: function(appInfo) {
              MultiFactorAuth2.instance = new MultiFactorAuth2(
                genericComponentOverrideContext.__assign(
                  genericComponentOverrideContext.__assign({}, normalisedConfig),
                  { appInfo, recipeId: MultiFactorAuth2.RECIPE_ID }
                )
              );
              return MultiFactorAuth2.instance;
            },
            webJS: MultiFactorAuthWebJS__default.default.init(
              genericComponentOverrideContext.__assign(
                genericComponentOverrideContext.__assign({}, normalisedConfig),
                {
                  override: {
                    functions: function(originalImpl, builder) {
                      var functions = getFunctionOverrides(normalisedConfig.onHandleEvent);
                      builder.override(functions);
                      builder.override(normalisedConfig.override.functions);
                      return originalImpl;
                    }
                  }
                }
              )
            )
          };
        };
        MultiFactorAuth2.getInstance = function() {
          return MultiFactorAuth2.instance;
        };
        MultiFactorAuth2.getInstanceOrThrow = function() {
          if (MultiFactorAuth2.instance === void 0) {
            var error = "No instance of MultiFactorAuth found. Make sure to call the MultiFactorAuth.init method.";
            if (typeof window === "undefined") {
              error = error + genericComponentOverrideContext.SSR_ERROR;
            }
            throw Error(error);
          }
          return MultiFactorAuth2.instance;
        };
        MultiFactorAuth2.prototype.addMFAFactors = function(secondaryFactors) {
          this.secondaryFactors = genericComponentOverrideContext.__spreadArray(
            genericComponentOverrideContext.__spreadArray(
              [],
              this.secondaryFactors.filter(function(factor) {
                return secondaryFactors.every(function(newFactor) {
                  return factor.id !== newFactor.id;
                });
              }),
              true
            ),
            secondaryFactors,
            true
          );
        };
        MultiFactorAuth2.prototype.isFirstFactorEnabledOnClient = function(factorId) {
          return this.config.firstFactors === void 0 || this.config.firstFactors.includes(factorId);
        };
        MultiFactorAuth2.prototype.getSecondaryFactors = function(userContext) {
          return this.config.getSecondaryFactorInfo(this.secondaryFactors, userContext);
        };
        MultiFactorAuth2.prototype.redirectToFactor = function(factorId, forceSetup, redirectBack, navigate, userContext) {
          if (forceSetup === void 0) {
            forceSetup = false;
          }
          if (redirectBack === void 0) {
            redirectBack = false;
          }
          return genericComponentOverrideContext.__awaiter(this, void 0, void 0, function() {
            var url, redirectUrl, redirectUrl;
            return genericComponentOverrideContext.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [
                    4,
                    this.getRedirectUrl(
                      { action: "GO_TO_FACTOR", forceSetup, factorId },
                      utils.getNormalisedUserContext(userContext)
                    )
                  ];
                case 1:
                  url = _b.sent();
                  if (url === null) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (redirectBack) {
                    redirectUrl = genericComponentOverrideContext.getCurrentNormalisedUrlPathWithQueryParamsAndFragments();
                    url = genericComponentOverrideContext.appendQueryParamsToURL(url, {
                      redirectToPath: redirectUrl
                    });
                  } else {
                    redirectUrl = genericComponentOverrideContext.getRedirectToPathFromURL();
                    if (redirectUrl) {
                      url = genericComponentOverrideContext.appendQueryParamsToURL(url, {
                        redirectToPath: redirectUrl
                      });
                    }
                  }
                  return [
                    2,
                    genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().redirectToUrl(
                      url,
                      navigate
                    )
                  ];
              }
            });
          });
        };
        MultiFactorAuth2.prototype.redirectToFactorChooser = function(redirectBack, nextFactorOptions, navigate, userContext) {
          if (redirectBack === void 0) {
            redirectBack = false;
          }
          if (nextFactorOptions === void 0) {
            nextFactorOptions = [];
          }
          return genericComponentOverrideContext.__awaiter(this, void 0, void 0, function() {
            var url, redirectUrl, redirectUrl;
            return genericComponentOverrideContext.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [
                    4,
                    this.getRedirectUrl(
                      { action: "FACTOR_CHOOSER", nextFactorOptions },
                      utils.getNormalisedUserContext(userContext)
                    )
                  ];
                case 1:
                  url = _b.sent();
                  if (url === null) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (redirectBack) {
                    redirectUrl = genericComponentOverrideContext.getCurrentNormalisedUrlPathWithQueryParamsAndFragments();
                    url = genericComponentOverrideContext.appendQueryParamsToURL(url, {
                      redirectToPath: redirectUrl
                    });
                  } else {
                    redirectUrl = genericComponentOverrideContext.getRedirectToPathFromURL();
                    if (redirectUrl) {
                      url = genericComponentOverrideContext.appendQueryParamsToURL(url, {
                        redirectToPath: redirectUrl
                      });
                    }
                  }
                  return [
                    2,
                    genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().redirectToUrl(
                      url,
                      navigate
                    )
                  ];
              }
            });
          });
        };
        MultiFactorAuth2.reset = function() {
          if (!genericComponentOverrideContext.isTest()) {
            return;
          }
          MultiFactorAuth2.instance = void 0;
          return;
        };
        var _a;
        _a = MultiFactorAuth2;
        MultiFactorAuth2.RECIPE_ID = "multifactorauth";
        MultiFactorAuth2.MultiFactorAuthClaim = new MultiFactorAuthClaimClass(
          function() {
            return MultiFactorAuth2.getInstanceOrThrow();
          },
          function(context, userContext) {
            return genericComponentOverrideContext.__awaiter(void 0, void 0, void 0, function() {
              return genericComponentOverrideContext.__generator(_a, function(_b) {
                switch (_b.label) {
                  case 0:
                    return [4, this.getInstanceOrThrow().getRedirectUrl(context, userContext)];
                  case 1:
                    return [2, _b.sent() || void 0];
                }
              });
            });
          }
        );
        return MultiFactorAuth2;
      }(index.RecipeModule)
    );
    exports.DEFAULT_FACTOR_CHOOSER_PATH = DEFAULT_FACTOR_CHOOSER_PATH;
    exports.MultiFactorAuth = MultiFactorAuth;
    exports.getAvailableFactors = getAvailableFactors;
  }
});

// node_modules/supertokens-auth-react/lib/build/index2.js
var require_index2 = __commonJS({
  "node_modules/supertokens-auth-react/lib/build/index2.js"(exports) {
    "use strict";
    var genericComponentOverrideContext = require_genericComponentOverrideContext();
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    var NormalisedURLPath = require_normalisedURLPath();
    var translationContext = require_translationContext();
    var reactDom = require_react_dom();
    var componentOverrideContext = require_multitenancy_shared();
    var recipe = require_multifactorauth_shared2();
    var types = require_multifactorauth_shared();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var React__default = _interopDefault(React);
    var NormalisedURLPath__default = _interopDefault(NormalisedURLPath);
    var ComponentOverrideContext = React__default.default.createContext("IS_DEFAULT");
    var dynamicLoginMethodsContext = React__default.default.createContext(void 0);
    var useDynamicLoginMethods = function() {
      var value = React__default.default.useContext(dynamicLoginMethodsContext);
      if (value === void 0) {
        throw new Error("useDynamicLoginMethods used outside of a valid provider (FeatureWrapper)");
      }
      return value;
    };
    var DynamicLoginMethodsProvider = function(_a) {
      var value = _a.value, children = _a.children;
      var contextValue = value === void 0 ? { loaded: false } : { loaded: true, loginMethods: value };
      return jsxRuntime.jsx(
        dynamicLoginMethodsContext.Provider,
        genericComponentOverrideContext.__assign({ value: contextValue }, { children })
      );
    };
    var UserContextContext = React__default.default.createContext(void 0);
    var useUserContext = function() {
      return React__default.default.useContext(UserContextContext);
    };
    var UserContextProvider = function(_a) {
      var children = _a.children, userContext = _a.userContext;
      var currentUserContext = React.useState(genericComponentOverrideContext.getNormalisedUserContext(userContext))[0];
      return jsxRuntime.jsx(
        UserContextContext.Provider,
        genericComponentOverrideContext.__assign({ value: currentUserContext }, { children })
      );
    };
    function FeatureWrapper(_a) {
      var children = _a.children, useShadowDom = _a.useShadowDom, defaultStore = _a.defaultStore;
      var userContext = useUserContext();
      var rethrowInRender = genericComponentOverrideContext.useRethrowInRender();
      var _b = React.useState(void 0), loadedDynamicLoginMethods = _b[0], setLoadedDynamicLoginMethods = _b[1];
      var st = genericComponentOverrideContext.SuperTokens.getInstanceOrThrow();
      React.useEffect(
        function() {
          if (loadedDynamicLoginMethods) {
            return;
          }
          genericComponentOverrideContext.Multitenancy.getInstanceOrThrow().getCurrentDynamicLoginMethods({ userContext }).then(
            function(loginMethods) {
              return setLoadedDynamicLoginMethods(loginMethods);
            },
            function(err) {
              return rethrowInRender(err);
            }
          );
        },
        [loadedDynamicLoginMethods, setLoadedDynamicLoginMethods]
      );
      if (genericComponentOverrideContext.SuperTokens.usesDynamicLoginMethods && !loadedDynamicLoginMethods) {
        return jsxRuntime.jsx(DynamicLoginMethodsSpinner, {});
      }
      return jsxRuntime.jsx(
        DynamicLoginMethodsProvider,
        genericComponentOverrideContext.__assign(
          { value: loadedDynamicLoginMethods },
          {
            children: jsxRuntime.jsx(
              translationContext.TranslationContextProvider,
              genericComponentOverrideContext.__assign(
                {
                  defaultLanguage: st.languageTranslations.defaultLanguage,
                  defaultStore: genericComponentOverrideContext.mergeObjects(
                    defaultStore,
                    st.languageTranslations.userTranslationStore
                  ),
                  translationControlEventSource: st.languageTranslations.translationEventSource,
                  userTranslationFunc: st.languageTranslations.userTranslationFunc
                },
                {
                  children: jsxRuntime.jsx(
                    WithOrWithoutShadowDom,
                    genericComponentOverrideContext.__assign(
                      { useShadowDom },
                      { children }
                    )
                  )
                }
              )
            )
          }
        )
      );
    }
    function WithShadowDom(_a) {
      var children = _a.children;
      var rootDiv = React.useRef(null);
      var _b = React.useState(), shadowRoot = _b[0], setShadowRoot = _b[1];
      React.useEffect(
        function() {
          if (rootDiv.current) {
            setShadowRoot(function(os) {
              return os || rootDiv.current.shadowRoot || rootDiv.current.attachShadow({ mode: "open", delegatesFocus: false });
            });
          }
        },
        [rootDiv]
      );
      return jsxRuntime.jsx(
        "div",
        genericComponentOverrideContext.__assign(
          { id: genericComponentOverrideContext.ST_ROOT_ID, ref: rootDiv },
          { children: shadowRoot && reactDom.createPortal(children, shadowRoot) }
        )
      );
    }
    function WithOrWithoutShadowDom(_a) {
      var children = _a.children, useShadowDom = _a.useShadowDom;
      if (useShadowDom === false) {
        return jsxRuntime.jsxs(
          "div",
          genericComponentOverrideContext.__assign(
            { id: genericComponentOverrideContext.ST_ROOT_ID },
            { children: [children, jsxRuntime.jsx(DisableAutoFillInput, {})] }
          )
        );
      }
      return jsxRuntime.jsxs(WithShadowDom, { children: [children, jsxRuntime.jsx(DisableAutoFillInput, {})] });
    }
    function DisableAutoFillInput() {
      return jsxRuntime.jsx(
        "style",
        genericComponentOverrideContext.__assign(
          { type: "text/css" },
          {
            children: "input.supertokens-input:-webkit-autofill,input.supertokens-input:-webkit-autofill:focus,input.supertokens-input:-webkit-autofill:hover,select:-webkit-autofill,select:-webkit-autofill:focus,select:-webkit-autofill:hover,textarea:-webkit-autofill,textarea:-webkit-autofill:focus,textarea:-webkit-autofill:hover{transition:background-color 5000s ease-in-out 0s}"
          }
        )
      );
    }
    function SpinnerIcon() {
      return jsxRuntime.jsx(
        "svg",
        genericComponentOverrideContext.__assign(
          { version: "1.1", viewBox: "25 25 50 50", "data-supertokens": "spinnerIcon" },
          {
            children: jsxRuntime.jsxs(
              "circle",
              genericComponentOverrideContext.__assign(
                {
                  cx: "50",
                  cy: "50",
                  r: "20",
                  fill: "none",
                  stroke: "rgb(var(--palette-primary))",
                  strokeWidth: "5",
                  strokeLinecap: "round",
                  strokeDashoffset: "0",
                  strokeDasharray: "100, 200"
                },
                {
                  children: [
                    jsxRuntime.jsx("animateTransform", {
                      attributeName: "transform",
                      attributeType: "XML",
                      type: "rotate",
                      from: "0 50 50",
                      to: "360 50 50",
                      dur: "4s",
                      repeatCount: "indefinite"
                    }),
                    jsxRuntime.jsx("animate", {
                      attributeName: "stroke-dashoffset",
                      values: "0;-30;-124",
                      dur: "2s",
                      repeatCount: "indefinite"
                    }),
                    jsxRuntime.jsx("animate", {
                      attributeName: "stroke-dasharray",
                      values: "0,200;110,200;110,200",
                      dur: "2s",
                      repeatCount: "indefinite"
                    })
                  ]
                }
              )
            )
          }
        )
      );
    }
    var useComponentOverride = function(overrideKey) {
      var ctx = React.useContext(ComponentOverrideContext);
      if (ctx === "IS_DEFAULT") {
        throw new Error("Cannot use component override outside ComponentOverrideContext provider.");
      }
      var OverrideComponent = ctx[overrideKey];
      return OverrideComponent === void 0 ? null : OverrideComponent;
    };
    var withOverride = function(overrideKey, DefaultComponent) {
      var finalKey = overrideKey + "_Override";
      DefaultComponent.displayName = finalKey;
      return function(props) {
        var OverrideComponent = useComponentOverride(finalKey);
        if (OverrideComponent !== null) {
          return jsxRuntime.jsx(
            OverrideComponent,
            genericComponentOverrideContext.__assign({ DefaultComponent }, props)
          );
        }
        return jsxRuntime.jsx(DefaultComponent, genericComponentOverrideContext.__assign({}, props));
      };
    };
    var styles = '[data-supertokens~="container"] {\n    --palette-background: 255, 255, 255;\n    --palette-inputBackground: 250, 250, 250;\n    --palette-inputBorder: 224, 224, 224;\n    --palette-primary: 255, 155, 51;\n    --palette-primaryBorder: 238, 141, 35;\n    --palette-success: 65, 167, 0;\n    --palette-successBackground: 217, 255, 191;\n    --palette-error: 255, 23, 23;\n    --palette-errorBackground: 255, 241, 235;\n    --palette-textTitle: 34, 34, 34;\n    --palette-textLabel: 34, 34, 34;\n    --palette-textInput: 34, 34, 34;\n    --palette-textPrimary: 101, 101, 101;\n    --palette-textLink: 0, 118, 255;\n    --palette-buttonText: 255, 255, 255;\n    --palette-textGray: 128, 128, 128;\n    --palette-superTokensBrandingBackground: 242, 245, 246;\n    --palette-superTokensBrandingText: 173, 189, 196;\n\n    --font-size-0: 12px;\n    --font-size-1: 14px;\n    --font-size-2: 16px;\n    --font-size-3: 19px;\n    --font-size-4: 24px;\n}\n/*\n * Default styles.\n */\n@keyframes slideTop {\n    0% {\n        transform: translateY(-5px);\n    }\n    100% {\n        transform: translateY(0px);\n    }\n}\n@keyframes swing-in-top-fwd {\n    0% {\n        transform: rotateX(-100deg);\n        transform-origin: top;\n        opacity: 0;\n    }\n    100% {\n        transform: rotateX(0deg);\n        transform-origin: top;\n        opacity: 1;\n    }\n}\n[data-supertokens~="container"] {\n    font-family: "Rubik", sans-serif;\n    margin: 12px auto;\n    margin-top: 26px;\n    margin-bottom: 26px;\n    width: 420px;\n    text-align: center;\n    border-radius: 8px;\n    box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.16);\n    background-color: rgb(var(--palette-background));\n}\n@media (max-width: 440px) {\n    [data-supertokens~="container"] {\n        width: 95vw;\n    }\n}\n[data-supertokens~="row"] {\n    margin: 0 auto;\n    width: 76%;\n    padding-top: 30px;\n    padding-bottom: 10px;\n}\n[data-supertokens~="superTokensBranding"] {\n    display: block;\n    margin: 10px auto 0;\n    background: rgb(var(--palette-superTokensBrandingBackground));\n    color: rgb(var(--palette-superTokensBrandingText));\n    text-decoration: none;\n    width: -webkit-fit-content;\n    width: -moz-fit-content;\n    width: fit-content;\n    border-radius: 6px 6px 0 0;\n    padding: 4px 9px;\n    font-weight: 400;\n    font-size: var(--font-size-0);\n    letter-spacing: 0.4px;\n}\n[data-supertokens~="generalError"] {\n    background: rgb(var(--palette-errorBackground));\n    padding-top: 10px;\n    padding-bottom: 10px;\n    margin-bottom: 10px;\n    margin-top: 24px;\n    padding-left: 18px;\n    padding-right: 18px;\n    letter-spacing: 0.2px;\n    font-size: var(--font-size-1);\n    border-radius: 8px;\n    color: rgb(var(--palette-error));\n    animation: swing-in-top-fwd 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) both;\n    word-wrap: break-word;\n}\n[data-supertokens~="headerTitle"] {\n    font-size: var(--font-size-4);\n    line-height: 40px;\n    letter-spacing: 0.58px;\n    font-weight: 500;\n    margin-bottom: 2px;\n    color: rgb(var(--palette-textTitle));\n}\n[data-supertokens~="headerSubtitle"] {\n    font-weight: 400;\n    color: rgb(var(--palette-textGray));\n    margin-bottom: 21px;\n}\n[data-supertokens~="headerSubtitle"][data-supertokens~="secondaryText"] {\n    color: rgb(var(--palette-textGray));\n    font-weight: 400;\n}\n[data-supertokens~="privacyPolicyAndTermsAndConditions"] {\n    max-width: 300px;\n    margin-top: 10px;\n}\n[data-supertokens~="privacyPolicyAndTermsAndConditions"] a {\n    line-height: 21px;\n}\n/* TODO: split the link style into separate things*/\n/* We add this before primary and secondary text, because if they are applied to the same element the other ones take priority */\n[data-supertokens~="link"] {\n    padding-left: 3px;\n    padding-right: 3px;\n    color: rgb(var(--palette-textLink));\n    font-size: var(--font-size-1);\n    cursor: pointer;\n    letter-spacing: 0.16px;\n    line-height: 26px;\n}\n[data-supertokens~="primaryText"] {\n    font-size: var(--font-size-1);\n    font-weight: 500;\n    letter-spacing: 0.4px;\n    line-height: 21px;\n    color: rgb(var(--palette-textLabel));\n}\n[data-supertokens~="secondaryText"] {\n    font-size: var(--font-size-1);\n    font-weight: 300;\n    letter-spacing: 0.4px;\n    color: rgb(var(--palette-textPrimary));\n}\n[data-supertokens~="secondaryText"] strong {\n    font-weight: 500;\n}\n[data-supertokens~="divider"] {\n    margin-top: 1.5em;\n    margin-bottom: 1.5em;\n    border-bottom: 0.3px solid #dddddd;\n    align-items: center;\n    padding-bottom: 5px;\n}\n[data-supertokens~="headerTinyTitle"] {\n    margin-top: 13px;\n    font-size: var(--font-size-3);\n    letter-spacing: 1.1px;\n    font-weight: 500;\n    line-height: 28px;\n}\n[data-supertokens~="secondaryLinkWithArrow"] {\n    margin-top: 10px;\n    margin-bottom: 30px;\n    cursor: pointer;\n}\n[data-supertokens~="secondaryLinkWithArrow"]:hover {\n    position: relative;\n    left: 2px;\n    word-spacing: 4px;\n}\n[data-supertokens~="generalSuccess"] {\n    color: rgb(var(--palette-success));\n    font-size: var(--font-size-1);\n    background: rgb(var(--palette-successBackground));\n    animation: swing-in-top-fwd 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) both;\n    padding: 9px 15px 9px 15px;\n    border-radius: 6px;\n    display: inline-block;\n}\n[data-supertokens~="spinner"] {\n    width: 80px;\n    height: auto;\n    padding-top: 20px;\n    padding-bottom: 40px;\n    margin: 0 auto;\n}\n[data-supertokens~="error"] {\n    color: rgb(var(--palette-error));\n}\n[data-supertokens~="linkButton"] {\n    font-family: "Rubik", sans-serif;\n    background-color: transparent;\n    border: 0;\n}\n[data-supertokens~="secondaryLinkWithLeftArrow"] {\n    color: rgb(var(--palette-textGray));\n    font-weight: 500;\n    margin-top: 10px;\n    margin-bottom: 40px;\n    cursor: pointer;\n}\n[data-supertokens~="secondaryLinkWithLeftArrow"] svg {\n    margin-right: 0.3em;\n}\n[data-supertokens~="secondaryLinkWithLeftArrow"]:hover svg {\n    position: relative;\n    left: -4px;\n}\n[data-supertokens~="button"] {\n    font-family: "Rubik", sans-serif;\n    background-color: rgb(var(--palette-primary));\n    color: rgb(var(--palette-buttonText));\n    width: 100%;\n    height: 34px;\n    font-weight: 700;\n    border-width: 1px;\n    border-style: solid;\n    border-radius: 6px;\n    border-color: rgb(var(--palette-primaryBorder));\n    background-position: center;\n    transition: all 0.4s;\n    background-size: 12000%;\n    cursor: pointer;\n}\n[data-supertokens~="button"]:disabled {\n    border: none;\n    cursor: no-drop;\n}\n[data-supertokens~="button"]:active {\n    outline: none;\n    transition: all 0s;\n    background-size: 100%;\n    filter: brightness(0.85);\n}\n[data-supertokens~="button"]:focus {\n    outline: none;\n}\n[data-supertokens~="backButtonCommon"] {\n    width: 16px;\n    height: 13px;\n}\n[data-supertokens~="backButton"] {\n    cursor: pointer;\n    border: none;\n    background-color: transparent;\n    padding: 0px;\n}\n[data-supertokens~="backButtonPlaceholder"] {\n    display: block;\n}\n[data-supertokens~="delayedRender"] {\n    animation-duration: 0.1s;\n    animation-name: animate-fade;\n    animation-delay: 0.2s;\n    animation-fill-mode: backwards;\n}\n@keyframes animate-fade {\n    0% {\n        opacity: 0;\n    }\n    100% {\n        opacity: 1;\n    }\n}\n[data-supertokens~="footerLinkGroupVert"] {\n    display: flex;\n    flex-direction: column;\n    margin-top: 10px;\n    gap: 24px;\n}\n[data-supertokens~="footerLinkGroupVert"] > div {\n    cursor: pointer;\n    margin: 0;\n}\n[data-supertokens~="footerLinkGroupVert"] [data-supertokens~="secondaryText"] {\n    font-weight: 400;\n}\n[data-supertokens~="footerLinkGroupVert"] [data-supertokens~="secondaryLinkWithLeftArrow"] {\n    font-weight: 500;\n    position: relative;\n    left: -6px; /* half the width of the left arrow */\n}\n@media (max-width: 360px) {\n    [data-supertokens~="footerLinkGroupVert"] {\n        flex-direction: column;\n    }\n    [data-supertokens~="footerLinkGroupVert"] > div {\n        margin: 0 auto;\n    }\n}\n[data-supertokens~="footerLinkGroupVert"] div:only-child {\n    margin-left: auto;\n    margin-right: auto;\n    margin-top: 14px;\n}\n[data-supertokens~="withBackButton"] {\n    position: relative;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n';
    var ThemeBase = function(_a) {
      var children = _a.children, userStyles = _a.userStyles, loadDefaultFont = _a.loadDefaultFont;
      return jsxRuntime.jsxs(React.Fragment, {
        children: [
          children,
          loadDefaultFont && jsxRuntime.jsx("link", {
            href: "//fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;600;700",
            rel: "stylesheet",
            type: "text/css"
          }),
          jsxRuntime.jsxs("style", { children: [styles, userStyles.join("\n")] })
        ]
      });
    };
    var MultitenancyDynamicLoginMethodsSpinnerTheme = function() {
      return jsxRuntime.jsx(
        "div",
        genericComponentOverrideContext.__assign(
          { "data-supertokens": "container delayedRender" },
          {
            children: jsxRuntime.jsx(
              "div",
              genericComponentOverrideContext.__assign(
                { "data-supertokens": "row" },
                {
                  children: jsxRuntime.jsx(
                    "div",
                    genericComponentOverrideContext.__assign(
                      { "data-supertokens": "spinner delayedRender" },
                      { children: jsxRuntime.jsx(SpinnerIcon, {}) }
                    )
                  )
                }
              )
            )
          }
        )
      );
    };
    var DynamicLoginMethodsSpinnerThemeWithOverride = withOverride(
      "MultitenancyDynamicLoginMethodsSpinnerTheme",
      MultitenancyDynamicLoginMethodsSpinnerTheme
    );
    var DynamicLoginMethodsSpinnerTheme = function(props) {
      return jsxRuntime.jsx(
        ThemeBase,
        genericComponentOverrideContext.__assign(
          { loadDefaultFont: false, userStyles: [props.config.rootStyle] },
          { children: jsxRuntime.jsx(DynamicLoginMethodsSpinnerThemeWithOverride, {}) }
        )
      );
    };
    var DynamicLoginMethodsSpinner = function() {
      var recipe2 = genericComponentOverrideContext.Multitenancy.getInstanceOrThrow();
      var recipeComponentOverrides = componentOverrideContext.useContext();
      return jsxRuntime.jsx(
        ComponentOverrideContext.Provider,
        genericComponentOverrideContext.__assign(
          { value: recipeComponentOverrides },
          {
            children: jsxRuntime.jsx(
              WithOrWithoutShadowDom,
              genericComponentOverrideContext.__assign(
                { useShadowDom: recipe2.config.useShadowDom },
                { children: jsxRuntime.jsx(DynamicLoginMethodsSpinnerTheme, { config: recipe2.config }) }
              )
            )
          }
        )
      );
    };
    var priorityOrder = [
      {
        rid: "thirdpartyemailpassword",
        includes: ["thirdparty", "emailpassword"],
        factorsProvided: [types.FactorIds.THIRDPARTY, types.FactorIds.EMAILPASSWORD]
      },
      {
        rid: "thirdpartypasswordless",
        includes: ["thirdparty", "passwordless"],
        factorsProvided: [
          types.FactorIds.THIRDPARTY,
          types.FactorIds.OTP_PHONE,
          types.FactorIds.OTP_EMAIL,
          types.FactorIds.LINK_PHONE,
          types.FactorIds.LINK_EMAIL
        ]
      },
      { rid: "emailpassword", includes: ["emailpassword"], factorsProvided: [types.FactorIds.EMAILPASSWORD] },
      {
        rid: "passwordless",
        includes: ["passwordless"],
        factorsProvided: [
          types.FactorIds.OTP_PHONE,
          types.FactorIds.OTP_EMAIL,
          types.FactorIds.LINK_PHONE,
          types.FactorIds.LINK_EMAIL
        ]
      },
      { rid: "thirdparty", includes: ["thirdparty"], factorsProvided: [types.FactorIds.THIRDPARTY] }
    ];
    function chooseComponentBasedOnFirstFactors(firstFactors, routeComponents) {
      var fallbackRid;
      var fallbackComponent;
      var _loop_1 = function(rid2, factorsProvided2) {
        if (firstFactors.every(function(factor) {
          return factorsProvided2.includes(factor);
        })) {
          var matchingComp = routeComponents.find(function(comp) {
            return comp.recipeID === rid2;
          });
          if (matchingComp) {
            fallbackRid = rid2;
            fallbackComponent = matchingComp;
            if (firstFactors.length === factorsProvided2.length) {
              genericComponentOverrideContext.logDebugMessage(
                "Rendering ".concat(rid2, " because it matches factors: ").concat(firstFactors, " exactly")
              );
              return { value: matchingComp };
            }
          }
        }
      };
      for (var _i = 0, priorityOrder_1 = priorityOrder; _i < priorityOrder_1.length; _i++) {
        var _a = priorityOrder_1[_i], rid = _a.rid, factorsProvided = _a.factorsProvided;
        var state_1 = _loop_1(rid, factorsProvided);
        if (typeof state_1 === "object")
          return state_1.value;
      }
      if (fallbackComponent !== void 0) {
        genericComponentOverrideContext.logDebugMessage(
          "Rendering ".concat(fallbackRid, " to cover ").concat(firstFactors, " as a fallback")
        );
        return fallbackComponent;
      }
      var enabledLoginMethods = [];
      if (firstFactors.includes(types.FactorIds.EMAILPASSWORD)) {
        enabledLoginMethods.push("emailpassword");
      }
      if (firstFactors.includes(types.FactorIds.THIRDPARTY)) {
        enabledLoginMethods.push("thirdparty");
      }
      if ([
        types.FactorIds.OTP_PHONE,
        types.FactorIds.OTP_EMAIL,
        types.FactorIds.LINK_PHONE,
        types.FactorIds.LINK_EMAIL
      ].some(function(pwlessFactorId) {
        return firstFactors.includes(pwlessFactorId);
      })) {
        enabledLoginMethods.push("passwordless");
      }
      genericComponentOverrideContext.logDebugMessage(
        "Choosing component using fallback logic w/ ".concat(enabledLoginMethods.join(", "), " enabled")
      );
      var enabledRecipeCount = enabledLoginMethods.length;
      var _loop_2 = function(rid2, includes2) {
        if (enabledRecipeCount === includes2.length && includes2.every(function(subRId) {
          return enabledLoginMethods.includes(subRId);
        })) {
          var matchingComp = routeComponents.find(function(comp) {
            return comp.recipeID === rid2;
          });
          if (matchingComp) {
            return { value: matchingComp };
          }
        }
      };
      for (var _b = 0, priorityOrder_2 = priorityOrder; _b < priorityOrder_2.length; _b++) {
        var _c = priorityOrder_2[_b], rid = _c.rid, includes = _c.includes;
        var state_2 = _loop_2(rid, includes);
        if (typeof state_2 === "object")
          return state_2.value;
      }
      var _loop_3 = function(rid2, includes2) {
        if (includes2.some(function(subRId) {
          return enabledLoginMethods.includes(subRId);
        })) {
          var matchingComp = routeComponents.find(function(comp) {
            return comp.recipeID === rid2;
          });
          if (matchingComp) {
            return { value: matchingComp };
          }
        }
      };
      for (var _d = 0, priorityOrder_3 = priorityOrder; _d < priorityOrder_3.length; _d++) {
        var _e = priorityOrder_3[_d], rid = _e.rid, includes = _e.includes;
        var state_3 = _loop_3(rid, includes);
        if (typeof state_3 === "object")
          return state_3.value;
      }
      throw new Error("No enabled recipes overlap with the requested firstFactors: " + firstFactors);
    }
    var RecipeRouter = (
      /** @class */
      function() {
        function RecipeRouter2() {
          var _this = this;
          this.getPathsToFeatureComponentWithRecipeIdMap = function() {
            if (_this.pathsToFeatureComponentWithRecipeIdMap !== void 0) {
              return _this.pathsToFeatureComponentWithRecipeIdMap;
            }
            var pathsToFeatureComponentWithRecipeIdMap = {};
            var features = _this.getFeatures();
            var featurePaths = Object.keys(features);
            for (var j = 0; j < featurePaths.length; j++) {
              var featurePath = featurePaths[j];
              if (pathsToFeatureComponentWithRecipeIdMap[featurePath] === void 0) {
                pathsToFeatureComponentWithRecipeIdMap[featurePath] = [];
              }
              pathsToFeatureComponentWithRecipeIdMap[featurePath].push(features[featurePath]);
            }
            _this.pathsToFeatureComponentWithRecipeIdMap = pathsToFeatureComponentWithRecipeIdMap;
            return _this.pathsToFeatureComponentWithRecipeIdMap;
          };
        }
        RecipeRouter2.getMatchingComponentForRouteAndRecipeIdFromPreBuiltUIList = function(normalisedUrl, preBuiltUIList, defaultToStaticList, dynamicLoginMethods) {
          var path = normalisedUrl.getAsStringDangerous();
          var isAuthPage = path === genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().appInfo.websiteBasePath.getAsStringDangerous();
          var routeComponents = preBuiltUIList.reduce(function(components, c) {
            var routes = c.getPathsToFeatureComponentWithRecipeIdMap();
            var _loop_4 = function(routePath2, routeComps2) {
              if (routePath2 === path || new RegExp("^" + routePath2.replace(/:\w+/g, "[^/]+").replace(/\/\*/g, "/[^/]+") + "$").test(path)) {
                components = components.concat(
                  routeComps2.map(function(c2) {
                    return { comp: c2, route: routePath2 };
                  })
                );
              }
            };
            for (var _i = 0, _a = Object.entries(routes); _i < _a.length; _i++) {
              var _b = _a[_i], routePath = _b[0], routeComps = _b[1];
              _loop_4(routePath, routeComps);
            }
            return components;
          }, []);
          var componentMatchingRid = routeComponents.find(function(c) {
            return c.comp.matches();
          });
          var defaultComp;
          if (routeComponents.length === 0) {
            defaultComp = void 0;
          } else if (componentMatchingRid !== void 0) {
            defaultComp = componentMatchingRid.comp;
          } else {
            defaultComp = routeComponents[0].comp;
          }
          var matchingNonAuthComponent = routeComponents.find(function(comp) {
            var ridlist = priorityOrder.map(function(a) {
              return a.rid;
            });
            return !ridlist.includes(comp.comp.recipeID) || comp.route !== genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().appInfo.websiteBasePath.getAsStringDangerous();
          });
          if (matchingNonAuthComponent) {
            return matchingNonAuthComponent.comp;
          }
          if (defaultToStaticList) {
            return defaultComp;
          }
          var mfaRecipe = recipe.MultiFactorAuth.getInstance();
          if (genericComponentOverrideContext.SuperTokens.usesDynamicLoginMethods === false) {
            if (componentMatchingRid) {
              return componentMatchingRid.comp;
            }
            if (isAuthPage && mfaRecipe && mfaRecipe.config.firstFactors !== void 0) {
              return chooseComponentBasedOnFirstFactors(
                mfaRecipe.config.firstFactors,
                routeComponents.map(function(c) {
                  return c.comp;
                })
              );
            } else {
              return defaultComp;
            }
          }
          if (dynamicLoginMethods === void 0) {
            throw new Error(
              "Should never come here: dynamic login methods info has not been loaded but recipeRouter rendered"
            );
          }
          if (componentMatchingRid && // if we find a component matching by rid
          (!priorityOrder.map(function(a) {
            return a.rid;
          }).includes(componentMatchingRid.comp.recipeID) || // from a non-auth recipe
          priorityOrder.some(function(a) {
            return a.rid === componentMatchingRid.comp.recipeID && a.factorsProvided.some(function(factorId) {
              return dynamicLoginMethods.firstFactors.includes(factorId);
            });
          }))) {
            return componentMatchingRid.comp;
          }
          if (isAuthPage) {
            return chooseComponentBasedOnFirstFactors(
              dynamicLoginMethods.firstFactors,
              routeComponents.map(function(c) {
                return c.comp;
              })
            );
          }
          return void 0;
        };
        return RecipeRouter2;
      }()
    );
    function RoutingComponent(props) {
      var _a, _b;
      var userContext = useUserContext();
      var rethrowInRender = genericComponentOverrideContext.useRethrowInRender();
      var _c = React.useState(void 0), loadedDynamicLoginMethods = _c[0], setLoadedDynamicLoginMethods = _c[1];
      var navigate = (_a = props.getReactRouterDomWithCustomHistory()) === null || _a === void 0 ? void 0 : _a.useHistoryCustom();
      var path = props.path;
      var location = (_b = props.getReactRouterDomWithCustomHistory()) === null || _b === void 0 ? void 0 : _b.useLocation();
      var componentToRender = React__default.default.useMemo(
        function() {
          var normalizedPath = new NormalisedURLPath__default.default(path);
          if (loadedDynamicLoginMethods !== void 0 || genericComponentOverrideContext.SuperTokens.usesDynamicLoginMethods === false) {
            var result = RecipeRouter.getMatchingComponentForRouteAndRecipeIdFromPreBuiltUIList(
              normalizedPath,
              props.preBuiltUIList,
              false,
              loadedDynamicLoginMethods
            );
            if (result === void 0 && genericComponentOverrideContext.SuperTokens.usesDynamicLoginMethods === true) {
              void redirectToAuth({ navigate, redirectBack: false });
            }
            return result;
          }
          return void 0;
        },
        [path, location, loadedDynamicLoginMethods, props.preBuiltUIList]
      );
      React.useEffect(
        function() {
          if (loadedDynamicLoginMethods) {
            return;
          }
          genericComponentOverrideContext.Multitenancy.getInstanceOrThrow().getCurrentDynamicLoginMethods({ userContext }).then(
            function(loginMethods) {
              return setLoadedDynamicLoginMethods(loginMethods);
            },
            function(err) {
              return rethrowInRender(err);
            }
          );
        },
        [loadedDynamicLoginMethods, setLoadedDynamicLoginMethods]
      );
      if (genericComponentOverrideContext.SuperTokens.usesDynamicLoginMethods && loadedDynamicLoginMethods === void 0) {
        return jsxRuntime.jsx(DynamicLoginMethodsSpinner, {});
      }
      if (componentToRender === void 0 || loadedDynamicLoginMethods === void 0 && genericComponentOverrideContext.SuperTokens.usesDynamicLoginMethods) {
        return null;
      }
      return jsxRuntime.jsx(componentToRender.component, { navigate });
    }
    function getSuperTokensRoutesForReactRouterDom$1(_a) {
      var getReactRouterDomWithCustomHistory = _a.getReactRouterDomWithCustomHistory, recipeList = _a.recipeList, basePath = _a.basePath;
      var routerInfo = getReactRouterDomWithCustomHistory();
      if (routerInfo === void 0) {
        return [];
      }
      var Route = routerInfo.router.Route;
      return Object.values(
        recipeList.reduce(function(routes, recipe2) {
          var pathsToFeatureComponentWithRecipeIdMap = recipe2.getPathsToFeatureComponentWithRecipeIdMap();
          Object.keys(pathsToFeatureComponentWithRecipeIdMap).forEach(function(path) {
            path = path === "" ? "/" : path;
            var pathForRouter = path;
            if (basePath !== void 0) {
              if (pathForRouter.startsWith(basePath)) {
                pathForRouter = pathForRouter.slice(basePath.length);
                if (!pathForRouter.startsWith("/")) {
                  pathForRouter = "/" + pathForRouter;
                }
              } else {
                throw new Error("basePath has to be a prefix of websiteBasePath passed to SuperTokens.init");
              }
            }
            if (!(path in routes)) {
              routes[path] = jsxRuntime.jsx(
                Route,
                genericComponentOverrideContext.__assign(
                  { exact: true, path: pathForRouter },
                  {
                    children: jsxRuntime.jsx(RoutingComponent, {
                      getReactRouterDomWithCustomHistory,
                      preBuiltUIList: recipeList,
                      path
                    })
                  }
                ),
                "st-".concat(path)
              );
            }
          });
          return routes;
        }, {})
      );
    }
    function getSuperTokensRoutesForReactRouterDomV6(_a) {
      var getReactRouterDomWithCustomHistory = _a.getReactRouterDomWithCustomHistory, recipeList = _a.recipeList, basePath = _a.basePath;
      var routerInfo = getReactRouterDomWithCustomHistory();
      if (routerInfo === void 0) {
        return [];
      }
      var Route = routerInfo.router.Route;
      return Object.values(
        recipeList.reduce(function(routes, recipe2) {
          var pathsToFeatureComponentWithRecipeIdMap = recipe2.getPathsToFeatureComponentWithRecipeIdMap();
          Object.keys(pathsToFeatureComponentWithRecipeIdMap).forEach(function(path) {
            path = path === "" ? "/" : path;
            var pathForRouter = path;
            if (basePath !== void 0) {
              if (pathForRouter.startsWith(basePath)) {
                pathForRouter = pathForRouter.slice(basePath.length);
                if (!pathForRouter.startsWith("/")) {
                  pathForRouter = "/" + pathForRouter;
                }
              } else {
                throw new Error("basePath has to be a prefix of websiteBasePath passed to SuperTokens.init");
              }
            }
            if (!(path in routes)) {
              routes[path] = jsxRuntime.jsx(
                Route,
                {
                  path: pathForRouter,
                  element: jsxRuntime.jsx(RoutingComponent, {
                    getReactRouterDomWithCustomHistory,
                    preBuiltUIList: recipeList,
                    path
                  })
                },
                "st-".concat(path)
              );
            }
          });
          return routes;
        }, {})
      );
    }
    var UI = (
      /** @class */
      function() {
        function UI2() {
        }
        UI2.getSuperTokensRoutesForReactRouterDom = function(reactRouterDom, preBuiltUiClassList, basePath) {
          if (preBuiltUiClassList === void 0) {
            preBuiltUiClassList = [];
          }
          if (reactRouterDom === void 0 || preBuiltUiClassList.length === 0) {
            throw new Error(
              // eslint-disable-next-line @typescript-eslint/quotes
              'Please use getSuperTokensRoutesForReactRouterDom like getSuperTokensRoutesForReactRouterDom(require("react-router-dom"), [EmailPasswordPreBuiltUI]) in your render function'
            );
          }
          var recipeList = preBuiltUiClassList.map(function(r) {
            return r.getInstanceOrInitAndGetInstance();
          });
          if (UI2.reactRouterDomIsV6 === void 0) {
            UI2.reactRouterDomIsV6 = reactRouterDom.withRouter === void 0;
          }
          if (UI2.reactRouterDomIsV6) {
            if (UI2.reactRouterDom === void 0) {
              var useNavigateHookForRRDV6 = function() {
                var navigateHook = reactRouterDom.useNavigate();
                var _a = React__default.default.useState(void 0), to = _a[0], setTo = _a[1];
                React__default.default.useEffect(
                  function() {
                    if (to !== void 0) {
                      setTo(void 0);
                      navigateHook(to);
                    }
                  },
                  [to, navigateHook, setTo]
                );
                return setTo;
              };
              UI2.reactRouterDom = {
                router: reactRouterDom,
                useHistoryCustom: useNavigateHookForRRDV6,
                useLocation: reactRouterDom.useLocation
              };
            }
            return getSuperTokensRoutesForReactRouterDomV6({
              getReactRouterDomWithCustomHistory: UI2.getReactRouterDomWithCustomHistory,
              recipeList,
              basePath
            });
          }
          if (UI2.reactRouterDom === void 0) {
            UI2.reactRouterDom = {
              router: reactRouterDom,
              useHistoryCustom: reactRouterDom.useHistory,
              useLocation: reactRouterDom.useLocation
            };
          }
          return getSuperTokensRoutesForReactRouterDom$1({
            getReactRouterDomWithCustomHistory: UI2.getReactRouterDomWithCustomHistory,
            recipeList,
            basePath
          });
        };
        UI2.canHandleRoute = function(preBuiltUiClassList) {
          var recipeList = preBuiltUiClassList.map(function(r) {
            return r.getInstanceOrInitAndGetInstance();
          });
          return RecipeRouter.getMatchingComponentForRouteAndRecipeIdFromPreBuiltUIList(
            genericComponentOverrideContext.getCurrentNormalisedUrlPath(),
            recipeList,
            true
          ) !== void 0;
        };
        UI2.getRoutingComponent = function(preBuiltUiClassList) {
          var recipeList = preBuiltUiClassList.map(function(r) {
            return r.getInstanceOrInitAndGetInstance();
          });
          return jsxRuntime.jsx(RoutingComponent, {
            getReactRouterDomWithCustomHistory: UI2.getReactRouterDomWithCustomHistory,
            path: genericComponentOverrideContext.getCurrentNormalisedUrlPath().getAsStringDangerous(),
            preBuiltUIList: recipeList
          });
        };
        UI2.getReactRouterDomWithCustomHistory = function() {
          return UI2.reactRouterDom;
        };
        return UI2;
      }()
    );
    var getSuperTokensRoutesForReactRouterDom = UI.getSuperTokensRoutesForReactRouterDom;
    var canHandleRoute = UI.canHandleRoute;
    var getRoutingComponent = UI.getRoutingComponent;
    function UserContextWrapper(props) {
      if (props.userContext !== void 0) {
        return jsxRuntime.jsx(
          UserContextProvider,
          genericComponentOverrideContext.__assign({ userContext: props.userContext }, { children: props.children })
        );
      }
      return jsxRuntime.jsx(UserContextContext.Consumer, {
        children: function(value) {
          if (value === void 0) {
            return jsxRuntime.jsx(UserContextProvider, { children: props.children });
          }
          return props.children;
        }
      });
    }
    var SessionContext = React__default.default.createContext({
      loading: true,
      isDefault: true
    });
    var SessionAuth = function(_a) {
      var _b;
      var children = _a.children, props = genericComponentOverrideContext.__rest(_a, ["children"]);
      var requireAuth = React.useRef(props.requireAuth);
      if (props.requireAuth !== requireAuth.current) {
        throw new Error(
          // eslint-disable-next-line @typescript-eslint/quotes
          'requireAuth prop should not change. If you are seeing this, it probably means that you are using SessionAuth in multiple routes with different values for requireAuth. To solve this, try adding the "key" prop to all uses of SessionAuth like <SessionAuth key="someUniqueKeyPerRoute" requireAuth={...}>'
        );
      }
      var _c = React.useState({ loading: true }), context = _c[0], setContext = _c[1];
      var session = React.useRef();
      var navigateHookRef = React.useRef(
        (_b = UI.getReactRouterDomWithCustomHistory()) === null || _b === void 0 ? void 0 : _b.useHistoryCustom
      );
      var navigate;
      try {
        if (navigateHookRef.current) {
          navigate = navigateHookRef.current();
        }
      } catch (_d) {
      }
      var userContext = useUserContext();
      var redirectToLogin = React.useCallback(function() {
        void genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().redirectToAuth({
          navigate,
          userContext,
          redirectBack: true
        });
      }, []);
      var buildContext = React.useCallback(function() {
        return genericComponentOverrideContext.__awaiter(void 0, void 0, void 0, function() {
          var sessionExists, invalidClaims, err_1, err_2;
          var _a2;
          return genericComponentOverrideContext.__generator(this, function(_b2) {
            switch (_b2.label) {
              case 0:
                if (session.current === void 0) {
                  session.current = types.Session.getInstanceOrThrow();
                }
                return [
                  4,
                  session.current.doesSessionExist({
                    userContext
                  })
                ];
              case 1:
                sessionExists = _b2.sent();
                if (sessionExists === false) {
                  return [
                    2,
                    {
                      loading: false,
                      doesSessionExist: false,
                      accessTokenPayload: {},
                      invalidClaims: [],
                      userId: ""
                    }
                  ];
                }
                _b2.label = 2;
              case 2:
                _b2.trys.push([2, 4, , 6]);
                return [
                  4,
                  session.current.validateClaims({
                    overrideGlobalClaimValidators: props.overrideGlobalClaimValidators,
                    userContext
                  })
                ];
              case 3:
                invalidClaims = _b2.sent();
                return [3, 6];
              case 4:
                err_1 = _b2.sent();
                return [
                  4,
                  session.current.doesSessionExist({
                    userContext
                  })
                ];
              case 5:
                if (_b2.sent()) {
                  throw err_1;
                }
                return [
                  2,
                  {
                    loading: false,
                    doesSessionExist: false,
                    accessTokenPayload: {},
                    invalidClaims: [],
                    userId: ""
                  }
                ];
              case 6:
                _b2.trys.push([6, 9, , 11]);
                _a2 = {
                  loading: false,
                  doesSessionExist: true,
                  invalidClaims
                };
                return [
                  4,
                  session.current.getAccessTokenPayloadSecurely({
                    userContext
                  })
                ];
              case 7:
                _a2.accessTokenPayload = _b2.sent();
                return [
                  4,
                  session.current.getUserId({
                    userContext
                  })
                ];
              case 8:
                return [2, (_a2.userId = _b2.sent(), _a2)];
              case 9:
                err_2 = _b2.sent();
                return [
                  4,
                  session.current.doesSessionExist({
                    userContext
                  })
                ];
              case 10:
                if (_b2.sent()) {
                  throw err_2;
                }
                return [
                  2,
                  {
                    loading: false,
                    doesSessionExist: false,
                    accessTokenPayload: {},
                    invalidClaims: [],
                    userId: ""
                  }
                ];
              case 11:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, []);
      var setInitialContextAndMaybeRedirect = React.useCallback(
        function(toSetContext) {
          return genericComponentOverrideContext.__awaiter(void 0, void 0, void 0, function() {
            var failureRedirectInfo;
            return genericComponentOverrideContext.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (context.loading === false) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!(props.doRedirection !== false))
                    return [3, 4];
                  if (!toSetContext.doesSessionExist && props.requireAuth !== false) {
                    redirectToLogin();
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!(toSetContext.invalidClaims.length !== 0))
                    return [3, 4];
                  return [
                    4,
                    types.getFailureRedirectionInfo({
                      invalidClaims: toSetContext.invalidClaims,
                      overrideGlobalClaimValidators: props.overrideGlobalClaimValidators,
                      userContext
                    })
                  ];
                case 1:
                  failureRedirectInfo = _a2.sent();
                  if (!(failureRedirectInfo.redirectPath !== void 0))
                    return [3, 3];
                  setContext(toSetContext);
                  return [
                    4,
                    genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().redirectToUrl(
                      failureRedirectInfo.redirectPath,
                      navigate
                    )
                  ];
                case 2:
                  return [2, _a2.sent()];
                case 3:
                  if (props.accessDeniedScreen !== void 0 && failureRedirectInfo.failedClaim !== void 0) {
                    console.warn({
                      message: "Showing access denied screen because a claim validator failed",
                      claimValidationError: failureRedirectInfo.failedClaim
                    });
                    return [
                      2,
                      setContext(
                        genericComponentOverrideContext.__assign(
                          genericComponentOverrideContext.__assign({}, toSetContext),
                          { accessDeniedValidatorError: failureRedirectInfo.failedClaim }
                        )
                      )
                    ];
                  }
                  _a2.label = 4;
                case 4:
                  setContext(toSetContext);
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        },
        [
          context.loading,
          props.doRedirection,
          props.requireAuth,
          props.overrideGlobalClaimValidators,
          props.accessDeniedScreen,
          redirectToLogin,
          userContext,
          navigate
        ]
      );
      genericComponentOverrideContext.useOnMountAPICall(buildContext, setInitialContextAndMaybeRedirect);
      React.useEffect(
        function() {
          function onHandleEvent(event) {
            return genericComponentOverrideContext.__awaiter(this, void 0, void 0, function() {
              var _a2, invalidClaims, failureRedirectInfo;
              return genericComponentOverrideContext.__generator(this, function(_b2) {
                switch (_b2.label) {
                  case 0:
                    _a2 = event.action;
                    switch (_a2) {
                      case "SESSION_CREATED":
                        return [3, 1];
                      case "REFRESH_SESSION":
                        return [3, 1];
                      case "ACCESS_TOKEN_PAYLOAD_UPDATED":
                        return [3, 1];
                      case "API_INVALID_CLAIM":
                        return [3, 1];
                      case "SIGN_OUT":
                        return [3, 7];
                      case "UNAUTHORISED":
                        return [3, 8];
                    }
                    return [3, 9];
                  case 1:
                    return [
                      4,
                      session.current.validateClaims({
                        overrideGlobalClaimValidators: props.overrideGlobalClaimValidators,
                        userContext
                      })
                    ];
                  case 2:
                    invalidClaims = _b2.sent();
                    if (!(props.doRedirection !== false))
                      return [3, 6];
                    return [
                      4,
                      types.getFailureRedirectionInfo({
                        invalidClaims,
                        overrideGlobalClaimValidators: props.overrideGlobalClaimValidators,
                        userContext
                      })
                    ];
                  case 3:
                    failureRedirectInfo = _b2.sent();
                    if (!failureRedirectInfo.redirectPath)
                      return [3, 5];
                    setContext(
                      genericComponentOverrideContext.__assign(
                        genericComponentOverrideContext.__assign({}, event.sessionContext),
                        { loading: false, invalidClaims }
                      )
                    );
                    return [
                      4,
                      genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().redirectToUrl(
                        failureRedirectInfo.redirectPath,
                        navigate
                      )
                    ];
                  case 4:
                    return [2, _b2.sent()];
                  case 5:
                    if (props.accessDeniedScreen !== void 0 && failureRedirectInfo.failedClaim !== void 0) {
                      console.warn({
                        message: "Showing access denied screen because a claim validator failed",
                        claimValidationError: failureRedirectInfo.failedClaim
                      });
                      return [
                        2,
                        setContext(
                          genericComponentOverrideContext.__assign(
                            genericComponentOverrideContext.__assign({}, event.sessionContext),
                            {
                              loading: false,
                              invalidClaims,
                              accessDeniedValidatorError: failureRedirectInfo.failedClaim
                            }
                          )
                        )
                      ];
                    }
                    _b2.label = 6;
                  case 6:
                    setContext(
                      genericComponentOverrideContext.__assign(
                        genericComponentOverrideContext.__assign({}, event.sessionContext),
                        { loading: false, invalidClaims }
                      )
                    );
                    return [
                      2
                      /*return*/
                    ];
                  case 7:
                    setContext(
                      genericComponentOverrideContext.__assign(
                        genericComponentOverrideContext.__assign({}, event.sessionContext),
                        { loading: false, invalidClaims: [] }
                      )
                    );
                    return [
                      2
                      /*return*/
                    ];
                  case 8:
                    setContext(
                      genericComponentOverrideContext.__assign(
                        genericComponentOverrideContext.__assign({}, event.sessionContext),
                        { loading: false, invalidClaims: [] }
                      )
                    );
                    if (props.onSessionExpired !== void 0) {
                      props.onSessionExpired();
                    } else if (props.requireAuth !== false && props.doRedirection !== false) {
                      redirectToLogin();
                    }
                    return [
                      2
                      /*return*/
                    ];
                  case 9:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          }
          if (session.current === void 0) {
            session.current = types.Session.getInstanceOrThrow();
          }
          if (context.loading === false) {
            return session.current.addEventListener(onHandleEvent);
          }
          return void 0;
        },
        [props, setContext, context.loading, userContext, navigate, redirectToLogin]
      );
      if (props.requireAuth !== false && (context.loading || !context.doesSessionExist)) {
        return null;
      }
      if (!context.loading && context.accessDeniedValidatorError && props.accessDeniedScreen) {
        return jsxRuntime.jsx(props.accessDeniedScreen, {
          userContext,
          navigate,
          validationError: context.accessDeniedValidatorError
        });
      }
      return jsxRuntime.jsx(
        SessionContext.Provider,
        genericComponentOverrideContext.__assign({ value: context }, { children })
      );
    };
    var SessionAuthWrapper = function(props) {
      return jsxRuntime.jsx(
        UserContextWrapper,
        genericComponentOverrideContext.__assign(
          { userContext: props.userContext },
          { children: jsxRuntime.jsx(SessionAuth, genericComponentOverrideContext.__assign({}, props)) }
        )
      );
    };
    var SuperTokensWrapper = function(props) {
      return jsxRuntime.jsx(
        SessionAuthWrapper,
        genericComponentOverrideContext.__assign({}, props, { requireAuth: false, doRedirection: false })
      );
    };
    var SuperTokensAPIWrapper = (
      /** @class */
      function() {
        function SuperTokensAPIWrapper2() {
        }
        SuperTokensAPIWrapper2.init = function(config) {
          genericComponentOverrideContext.SuperTokens.init(config);
        };
        SuperTokensAPIWrapper2.changeLanguage = function(language) {
          return genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().changeLanguage(language);
        };
        SuperTokensAPIWrapper2.loadTranslation = function(store) {
          return genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().loadTranslation(store);
        };
        var _a;
        _a = SuperTokensAPIWrapper2;
        SuperTokensAPIWrapper2.SuperTokensWrapper = SuperTokensWrapper;
        SuperTokensAPIWrapper2.redirectToAuth = function(options) {
          return genericComponentOverrideContext.__awaiter(void 0, void 0, void 0, function() {
            var _b;
            return genericComponentOverrideContext.__generator(_a, function(_c) {
              return [
                2,
                genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().redirectToAuth(
                  genericComponentOverrideContext.__assign(
                    genericComponentOverrideContext.__assign({}, options),
                    {
                      redirectBack: (_b = options === null || options === void 0 ? void 0 : options.redirectBack) !== null && _b !== void 0 ? _b : true,
                      userContext: genericComponentOverrideContext.getNormalisedUserContext(
                        options === null || options === void 0 ? void 0 : options.userContext
                      )
                    }
                  )
                )
              ];
            });
          });
        };
        SuperTokensAPIWrapper2.useTranslation = translationContext.useTranslation;
        SuperTokensAPIWrapper2.useUserContext = useUserContext;
        return SuperTokensAPIWrapper2;
      }()
    );
    var init = SuperTokensAPIWrapper.init;
    var changeLanguage = SuperTokensAPIWrapper.changeLanguage;
    var loadTranslation = SuperTokensAPIWrapper.loadTranslation;
    var redirectToAuth = SuperTokensAPIWrapper.redirectToAuth;
    exports.ComponentOverrideContext = ComponentOverrideContext;
    exports.FeatureWrapper = FeatureWrapper;
    exports.RecipeRouter = RecipeRouter;
    exports.SessionAuthWrapper = SessionAuthWrapper;
    exports.SessionContext = SessionContext;
    exports.SpinnerIcon = SpinnerIcon;
    exports.SuperTokensAPIWrapper = SuperTokensAPIWrapper;
    exports.SuperTokensWrapper = SuperTokensWrapper;
    exports.UI = UI;
    exports.UserContextContext = UserContextContext;
    exports.UserContextWrapper = UserContextWrapper;
    exports.canHandleRoute = canHandleRoute;
    exports.changeLanguage = changeLanguage;
    exports.getRoutingComponent = getRoutingComponent;
    exports.getSuperTokensRoutesForReactRouterDom = getSuperTokensRoutesForReactRouterDom;
    exports.init = init;
    exports.loadTranslation = loadTranslation;
    exports.redirectToAuth = redirectToAuth;
    exports.useDynamicLoginMethods = useDynamicLoginMethods;
    exports.useUserContext = useUserContext;
    exports.withOverride = withOverride;
  }
});

export {
  require_translationContext,
  require_multitenancy_shared,
  require_multifactorauth2 as require_multifactorauth,
  require_sessionClaimValidatorStore4 as require_sessionClaimValidatorStore,
  require_multifactorauth_shared2,
  require_index2
};
//# sourceMappingURL=chunk-GTUEWSF2.js.map
